use Call, Calls, HistoricalCalls, HistoricalEvents, Events, Len, Min, Range, Sum, FilterAddressesInTrace, BlockNumber from hexagate;

param disputeGame: address; 

// Filter to only run this invariant if the disputeGame address is in the trace
source addressesInTrace: list<address> = FilterAddressesInTrace {
    addresses: list(disputeGame)
};

// Get the DelayedWETH address for the provided dispute game
source delayedWETH: address = Call {
    contract: disputeGame,
    signature: "function weth() returns (address)"
};

// Retrieve all past resolveClaim calls, tracking claim indices and resolutions
// This helps determine which claims have been resolved and which are pending
source resolveClaimCalls: list<tuple<integer,integer>> = HistoricalCalls {
    contract: disputeGame,
    signature: "function resolveClaim(uint256 _claimIndex, uint256 _numToResolve)"
};

// Parse out just the claim indices from the historical resolveClaim calls
source claimIndices: list<integer> = [
    claim[0] for claim in resolveClaimCalls
];

// Similar to the resolveClaim calls, retrieve all unlock calls on the delayedWETH contract
source unlocksWithSender: list<tuple<address,tuple<address,integer>>> = HistoricalCalls {
    contract: delayedWETH,
    signature: "function unlock(address _guy, uint256 _wad)",
    withSender: true
};

// Filter out only the unlock calls that originated from the currrent disputeGame contract
source unlockAmounts: list<integer> = [
    unlock[1][1] for unlock in unlocksWithSender if (unlock[0] == disputeGame)
];

// For all the resolve claim call(s), determine the smallest (aka topmost) value
// Even though an unknown number of subgames may have been resolved, we know that the provided claimIndex
//   to resolveClaim will always be the topmost index because resolveClaim resolves from bottom to top
source minClaimIndex: integer = Len { sequence: resolveClaimCalls } == 0 ? 0 : Min { sequence: claimIndices };

// With the minClaimIndex (exclusive), generate the remaining range of indices left that need to be resolved
source indicesRange: list<integer> = Range { start: 0, stop: minClaimIndex};

// Compute expected bond values per claim index
// We DO NOT count subgames because every claim has its own claim index, even if it is a subgame of another claim,
// meaning it will already be accounted for in indicesRange
source ethBondsPerClaimIndex: list<integer> = [
    Call {
        contract: disputeGame,
        signature: "function getRequiredBond(uint128 _position) returns (uint256 requiredBond_)",
        params: tuple(2 ** index)
    }
    for index in indicesRange
];

// Compute bond requirement at minClaimIndex (if applicable)
// If there are still subgames left to resolve, include the claim in the future eth bonds,
// otherwise, the minClaimIndex will be part of the past eth bonds claimed
// Caveat: We assume that the subgames involved in a given claim index have already been resolved at this point for simplicity
source ethBondAtMinClaim: integer = Call { 
    contract: disputeGame, 
    signature: "function getNumToResolve(uint256) returns (uint256)", 
    params: tuple(minClaimIndex)
} == 0 ? 0 : Call { 
    contract: disputeGame, 
    signature: "function getRequiredBond(uint128) returns (uint256)", 
    params: tuple(2 ** minClaimIndex)
};

// Track withdrawals occurring in the current block
// These are real-time events and must be accounted for separately
source currentWithdrawal: list<tuple<integer>> = Events {
    contract: disputeGame,
    signature: "event ReceiveETH(uint256 amount)"
};

// Retrieve past withdrawal events, including block numbers
// Used to track ETH withdrawals over historical blocks
source pastWithdrawalEvents: list<tuple<integer, tuple<integer>>> = HistoricalEvents {
    contract: disputeGame,
    signature: "event ReceiveETH(uint256 amount)",
    withBlocks: true
};

// Extract past withdrawal amounts, excluding the current block
source pastWithdrawals: list<integer> = [
    withdrawal[1][0]  // Extract withdrawal amount from nested tuple
    for withdrawal in pastWithdrawalEvents
    if withdrawal[0] < BlockNumber {}  // Ensure only withdrawals from previous blocks are counted
];

// Extract amounts from current block withdrawal events
// Since past withdrawals don't account for real-time activity, this ensures accurate balance calculation
source currentWithdrawals: list<integer> = [
    withdrawal[0] for withdrawal in currentWithdrawal
];

// Retrieve the current ETH balance of the dispute game in the DelayedWETH contract
// This is the real-time ETH balance available in the contract
source currDisputeEthBalance: integer = Call {
    contract: delayedWETH,
    signature: "function balanceOf(address) returns (uint256)",
    params: tuple(disputeGame)
};

// Compute total expected ETH unlocks based on past claim resolutions
// Ensures the monitor tracks pending ETH claims that haven't been withdrawn yet
source futureEthUnlocked: integer = Len { sequence: resolveClaimCalls } == 0
    ? currDisputeEthBalance
    : Sum { sequence: ethBondsPerClaimIndex } + ethBondAtMinClaim;

// Compute total ETH balance, including past and current withdrawals
// This accounts for both previous and real-time withdrawals from the dispute game
source totalDisputeEthBalance: integer = currDisputeEthBalance + Sum { sequence: pastWithdrawals } + Sum { sequence: currentWithdrawals };

// There are 2 totals: past and current ETH unlocked, and future ETH unlocked
// When the 2 totals are summed and subtracted from the balance of the dispute game contract's DelayedWETH
// balance, the final value should ALWAYS be equal to 0
invariant {
    description: "Dispute Game ETH imbalance detected between total balance, unlocks, and withdrawals",
    condition: (Len { sequence: addressesInTrace } > 0) ? ((totalDisputeEthBalance - (futureEthUnlocked + Sum { sequence: unlockAmounts })) == 0) : true
};